1) Écrire une structure TypeClient (enum) permettant de distinguer un client particulier d’un client professionnel avec deux champs dédiés pour chacun des deux types.
2) Les dates de locations seront gérées par une classe GestionDates contenant un attribut date (String), un attribut final format (‘’dd/MM/yyyy’’) et une instance de la classe SimpleDateFormat.
3) Les clients seront soit des particuliers (classe ClientPartiuculier, attributs : nom, prénom, age, adresse, un type (TypeClient), une date et un nombre de locations) ou professionnel (ClientProfessionnel, attributs : nom, type, date de location et le taux de remise appliqué aux clients professionnels). Ajoutez les constructeurs, etc. et autres méthodes vous paraissant nécessaires maintenant ou durant le projet.
4) Ajoutez une classe Clients de type ArrayList (et non pas une classe contenant une ArrayList ...) permettant de sauvegarder des clients particuliers ou professionnels avec une méthode affiche permettant l’affichage des clients. On ne pourra crée qu’une seule instance de Clients. Modifez le ou les constructeur(s) de manière à ajouter une nouvelle instance de client particulier ou professionnel à la liste de clients de Clients.

1) Écrire une structure NombreDePortes (enum) permettant de caractériser différents types de véhicules (deux, trois, quatre ou cinq portes). Chacune des ces valeurs sera associée à un nombre (nombre de portes) et à une description (par exemple « polyvalente et compact » pour les véhicules comportant trois portes). Ajoutez des getters permettant de récupérer les éléments descriptifs de chaque type de voiture.
2) De même que pour le type de client (section A-1), proposez une structure Constructeur contenant la marque de l’automobile (« Peugeot », etc.).
3) Pour terminer la caractérisation d’un véhicule, ajoutez un enum permettant d’informer le type de véhicule (TypeVehicule) contenant le type (Berline, Break et Utilitaire), le prix de location à la journée ainsi qu’une courte description (par exemple « Famille » pour break). De même que pour NombreDePortes, il est nécessaire de pouvoir récupérer les diférents champs descriptifs avec des méthodes dédiées à chaque élément. 4) Ajoutez une classe Immatriculation contenant un champs identifcation (String). Il faut que l’on soit capable d’évaluer si deux immatriculations sont identiques et donc deux véhicules.
5) Proposez trois classes correspondant à chaque type de véhicule (Berline, Break et Utilitaire) contenant les champs : le type de véhicule, le nombre de portes du véhicule, l’immatriculation, le constructeur (Constructeur : Peugeot, etc), le modèle (String), le kilométrage et le prix d’achat (double). Ajoutez un constructeur permettant d’initialiser ces attributs.
6) De même que vous l’avez réalisé pour les Clients, implémentez une classe Vehicules de type Vector (et non pas une classe contenant un Vector ...) permettant de sauvegarder des véhicules avec une méthode affiche permettant l’affichage des véhicules. On ne pourra créer qu’une seule instance de Vehicules. Modifez le ou les constructeur(s) de manière à ajouter une nouvelle instance de d'un véhicule (quel que soit son type) à la liste des véhicules de Vehicules.

1) Avant de procéder à l’implémentation des classes de gestion de la location/vente des véhicules, vous allez ajouter une classe de structuration des informations Gestion qu’il n’est pas possible d’instancier, ayant pour rôle de sauvegarder toutes les données permettant de gérer les locations/ventes : les véhicules disponibles à la location (HashSet) et disponibles à la vente (LinkedList) ainsi que les véhicules en cours de location (HashMap) sous forme d’un tableau associant un client à une automobile. La classe Gestion disposera également des attributs indiquant le kilométrage à partir duquel un véhicule est disposé à la vente (double) ainsi que le kilométrage maximum à pattir duquel un véhicule ne peut plus être proposé à la vente (double).
2) Écrivez ensuite une classe GestionLocation qui sera composée des méthodes demandeDeLocation et getTarif qui prendront en paramètre une voiture et un client et de la méthode finDeLocation qui elle aura comme argument, en plus des deux précédents, la date et le kilométrage de fin de location. Ajoutez aux véhicules les attributs kilometrageFin et dateFin nécessaire à l’estimation du tarif de location. demandeDeLocation permettra d’ajouter le véhicule dans les collections adéquats de Gestion (fin de location, disponible à la vente au vu du nouveau kilométrage ?, mise-à-jour de la date de début de location pour le client, etc.) et d’incrémenter le nombre de locations déjà effectuées par le client particulier (retourne true si tout c’est bien passé). Cette méthode vérifera si le véhicule est contenu dans la liste des véhicules disponibles (HashSet) de la classe Gestion à l’aide de la méthode contains. Modifez votre code pour permettre cela. finDeLocation mettra à jour les collections de la classe Gestion et retournera la facture à l’aide de la méthode getTarif explicitée ci-après.
3) La méthode getTarif dans la classe GestionLocation, retournera le prix de la location dans le cas d’un client particulier ou un professionnel et dans la classe GestionVente le prix de vente. Dans le cas de la location, elle fera appel à la méthode prixLocation de la classe Gestion (à implémenter) qui permettra de retourner le prix de la location et sera égale à : reduction x (prixParKilometrePourCeTypeDeVehicule x kilometrageEffectue + prixParuourPourCeTypeDeVehicule x nombreDeuour x (1 + nombreDePortes/10) ). La réduction ne peut être négative.
Pour un client particulier, la réduction sera égale à : 1.0 – 0.005 x nbLocations, et pour un client professionnel, la réduction sera égale au taux. Pour la réalisation de ce calcul du prix de la location, faites en sorte de ne pas avoir à tester le type de l’instance du client. De plus, la méthode prixLocation ne prend pas en paramètre de client.
4) Dans le cas d’une vente dans la classe GestionVente, la méthode getTarif retournera le prix du véhicule calculé comme suit : prixDachat x kilometrageDuVehicule / kilometrageMaximumPourUneVente (Gestion). Vous ajouterez à la classe GestionVente la méthode demandeDeVente qui utilisera la méthode getTarif pour retourner le prix du véhicule et mettra à jour les collections de la classe Gestion et de la classe Vehicules.

1) Écrire dans la classe Sauvegarde qui permettra de serializer/deserializer les Clients, les Vehicules ainsi que l’ensemble des collections de la classe Gestion dans un répertoire donné à l’aide des méthode sauvegardeDonnes et chargementDonnees. Les flux seront gérés par desObjectOutputStream/ObjectInputStream. Ces deux méthodes prendront en paramètre un répertoire (String) et ne retourneront rien. Ajoutez à Clients et Vehicules les méthodes setInstance dédiées pour chacune des deux classes.
2) Écrire l’ensemble des exception nécessaire pour chacune des classe. Pour ce faire, vous étendrez la classe Exception pour obtenir GestionAutomobileException. Depuis cette dernière vous écrirez et utiliserez un ensemble d’exceptions dérivées de GestionAutomobileException hiérarchisez dédiées à chaque cas de figure et chaque type d’instance.
3) A partir de cette classe, créer une seconde classe GestionAutomobileClientsException, exception qui sera levée si l’on essaie d’ajouter deux fois un même client dans la classe Clients (même nom, etc.). Ajoutez à cette classe un constructeur avec une chaîne de caractères. Réécrire la méthode permettant l’ajout d’un client (particulier ou professionnel) de façon à ce qu’elle lève GestionAutomobileClientsException : l’exception se construit en faisant passer une chaîne indiquant l’identité du client particulier ou professionnel et un message soulignant que ce client existe déjà dans la classe Clients. Ajoutez la classe GestionAutomobileClientsParticuliersException dérivée de GestionAutomobileClientsException qui sera levée dans le cas pour lequel l’utilisateur tentera de créer un client avec un age négatif.
4) Créer une classe GestionAutomobileVehiculesException qui étendra la classe GestionAutomobileException. Écrivez la classe dérivée GestionAutomobileVehiculesVenteException dérivée de GestionAutomobileVehiculesException qui sera levée si on tente de vendre un véhicule pour lequel le kilométrage dépasse la valeur maximale définit dans la classe Gestion. Cette classe aura un constructeur sans argument, mais initialisera le message de sa classe de base «Ce véhicule n’est plus dis- ponible à la vente». Enfin, ajoutez la classe dérivée GestionAutomobileVehiculesLocationException qui sera levée dans la méthode demandeDeLocation de GestionLocation si on désire louer un véhicule ne fgurant pas dans la liste des véhicules disponibles à la location.

 1) Proposez une méthode testLocation employée dans un main de la classe Test permettant de tester la location de diférents types d’automobile (Berline, etc.) avec diférentes confgurations (2 portes, etc.) et diférents types de client (particulier ou professionnel). Sauvegardez les données en les serializant en vous assurant qu’un véhicule satisfasse les conditions pour être disponible à la vente.
2) Écrivez ensuite dans le même main une méthode testVente permettant de tester la vente d’un véhicule. Celle-ci procédera au chargement des données dans un premier temps puis exécutera la vente d’un véhicule et afichera le résultat de la vente.
3) Ajoutez enfin des cas d’usage permettant de tester vos exceptions à l’aide de la méthode getMessage() dans le cas de la création de clients, de demande de location ou de mise à la vente d’un véhicule dans une méthode testException toujours employée dans le même main.
